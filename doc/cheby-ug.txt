= Cheby User Guide
CERN
v1.7.dev0, 2025-03-24

== What is Cheby ?

*Cheby* is both a text description of the interface between hardware
and software, and a tool to automatically generate code or
documentation from the text files.

In Cheby, the hardware appears to the software as a block of address in the
physical memory space.  There might be other way to interface hardware and
software (for example through a standard serial bus like USB or through a
network).

The block of address is named the memory map of the hardware.  The memory map
is a map between addresses and hardware elements like registers or memories.

The hardware elements supported by Cheby are:

* Registers.  A register uses one word of memory (usually 32 bits) or
two (so 64 bits), and is divided into fields (a group of bit).  Some
bits of the registers can be unused.  The difference between a
register and a memory is that hardware has direct access to a
register, there are wires between the register and the hardware so as
soon as the software writes to a register the hardware 'can' see the
new value. A register is usually read-write: the value of the register
is defined by the last write (from the software) and the software
always reads the last value.  A register can also be read-only: the
hardware defines the value that is read.  It is also possible that a
read triggers some changes in the hardware.  Finally a register can be
write-only, and usually a write triggers an action.  In that case, a
value read has no meaning.

* Memories. A memory is like a RAM memory except that hardware also
has access to it (through a second port, hence the name dual
port).  Memories are used when a certain amount of data has to be
transferred or to configure hardware for data transfers (like DMA
descriptors).  To avoid possible conflicts, memories are usually one
direction: the software can read and the hardware can write, or the
software can write and the hardwire can read.

* Submap.  A submap is a sub-block of the memory map (an aligned
continuous range of address) either defined by an external file or
will be available to the hardware designer.  Submaps make possible to
create a hierarchy of blocks and to create custom blocks.

A fundamental feature of the Cheby text description is non-ambiguity: the
memory map is defined by the file and there is only one way to assign addresses
to hardware elements.

Once the text file is written it is possible to invoke the cheby tool to
generate:

* C headers
* Device drivers
* HDL code
* HTML, markdown, and Latex documentation

The automatic generation of these files avoid a tedious work and ensure
coherency between them.


== User Starting Guide

Let's work on a very simple design: a counter.  The hardware
increments a counter every cycle until it reaches a maximal value,
then it starts again from 0.

As a designer, you have to implement the counter but you can use Cheby
to generate the interface.  The counter needs:

* A one bit register to enable/disable it.

* A 32-bit register containing the maximal value

* A 32-bit register with the current value.

In this user starting guide only the `cheby` command line tool is used, and
the input file is created by any text editor.

Let's assume the design uses the wishbone bus, and create a Cheby file that
describes the above elements.

[source]
----
include::srcs/counter.cheby[]
----

The description of the file format is documented later in this guide.

For the hardware designer, cheby can generate the hardware interface:
for VHDL this is an entity and its associated architecture and for
Verilog this is a module.  The hardware interface contains the wishbone bus,
the registers described in the file, the decoding logic, and ports for the
registers.

To generate VHDL:
[source]
----
  cheby --gen-hdl=counter.vhdl -i counter.cheby
----

Here is the entity part generated by the tool:
[source]
----
include::srcs/counter_entity.vhdl[]
----

You can see the wishbone ports and the ports for the counter.

As an hardware designer, you have to write the HDL code for the counter logic.
The enable and maximum value are given by the interface, and you should give
the current value.

Because the interface is defined (and hopefully well documented), it is also
possible for the software developer to start the software part.  The SW
developer needs to program the register and therefore to know the register
map.  So let's generate the corresponding C header:
[source]
----
include::srcs/counter.h[]
----

The absolute address of the counter is determined by the instantiation
of this module, but you can refer directly to the registers.

In order for the end-user or a developer to have a better view of the design,
it is better to read a documentation.  A doc can be generated from the
description file:

[source]
----
  cheby --gen-doc=counter.html -i counter.cheby
----

For our example, the generated doc is:

include::srcs/counter-reindent.md[]

== Cheby File Format

=== General Structure

The Cheby file format represent a hierarchy of nodes.  A node contains
a list of attribute and children.  An attribute is designated by a name and
has a value (a string, a boolean or an integer).  The children are nodes,
organized as a list.

The Cheby file format described in this manual is based on YAML, so
that there is no new format to invent and many text editors have
already support for it.  However the file extension is usually
`.cheby`.

The nodes are `memory-map`, `reg`, `field`, `memory`, `repeat`, `block`
and `submap`.

Some attributes are common to all nodes:

* `name`: The name of the node.  This is required for all nodes.  The name is
also used to create HDL or C names in general files.

* `comment`: A short text that explain the purpose. It is copied into the code
(as a comment). This attribute is not required but it is recommended to always
provide it.

* `description`: A longer text that explain the purpose in detail. It is copied
into the generated documentation. Newlines are honored according to the YAML
specification. In regular strings, you can add an empty line to generate a
newline. Alternatively, you can also explicitly add them in double-quoted
strings, e.g. `description: "line1 \n line2"`.

* `children`: For nodes that have children, this is a list of the children.

* `address`: An optional byte address relative to the parent.  The address must
be correctly aligned.  If not provided or it the value is `next`, then the
address is computed using the previous one and the alignment.  It is possible
to go backward by providing explicit address (e.g.: the first child has address
4 and the second one has address 0), but this is not recommended and be a source
of errors (in particular with automatic addresses that are always computed
from the previous node). Overlapping addresses are detected by the tools.

* `x-NAME`: Extensions for tool or feature `NAME`. The Cheby file
format is extensible so that new tools can be easily created without
backward compatibility issues.

* `x-hdl`: Extensions for hdl generation.

* `x-gena`: Extensions for Gena compatibility.

* `x-wbgen`: Extensions for wbgen compatibility.

More extensions and their arguments are documented in a dedicated chapter below.

=== Header

A cheby file is an associative array named `memory-map`.  The only purpose of
this name is to easily refuse a random YAML file.

The `bus` attribute specifies which bus will be used to interface the CPU with
the HW module.  It can be:

* apb-32: APB bus with 32 bit of data

* avalon-lite-32: AVALON bus with 32 bit of data

* axi4-lite-32: AIX4 lite bus with 32 bit of data

* cern-be-vme-SZ: CERN VME-like bus using `SZ` data bit.  `SZ` can be
8, 16 or 32.

* cern-be-vme-split-SZ: CERN vme-like bus with split read and write address lines

* wb-32-be: non-pipelined wishbone with 32 bit of data using the big-endian
convention

* wb-16, wb-32: non-pipelined wishbone using 16 or 32 bit of data and big-endian convention by default

* simple-32: a simple bus (with 32 bit of data) based on strobe and ack pulses.

* sram: an even simpler bus (with 32 bit of data) without ack signal
  so data is expected on the next clock tick. As such, it can **not**
  be used as a `bus` but only as an `interface` for RAM or Submap
  elements.

The attribute `word-endian` can be used to specify the word endianness
(how multi-word registers are laid out in memory).  It is optional,
and the default is set according to the bus: `big` by default for
`wb-32-be` and `cern-be-vme`, `little` for `apb-32`, `axi4-lite-32`,
`simple-32` and `avalon-lite-32`.  It is possible to use `none` to
disallow any multi-word registers, and thus having also a portable
memory map.

If you need to reserve area in a module, you can use the `size`
attribute to specify the size (in bytes) of the memory space used by
the module.  The suffixes k, M and G are allowed.

It is possible to specify a semantic version using the `version`
attribute.  The version consists of 3 numbers between 0 and 255
separated by a dot.  The version appears in generated files. Note that
`memory-map/version` *is now deprecated*, use
`x-map-info/memmap-version` instead - see lower.

The following attributes under `x-hdl` are supported:

`busgroup`:: Use an input and an output record (in vhdl) for the bus.  The
value is a boolean.

`iogroup`:: Use an input and and output record (in vhdl) for the I/O. This
will also generate a package to declare the records.  The value of this
attribute is the name of the port.

`reg-prefix`:: If false, discard register prefix and every prefix before
register.  So only the name of the field is kept. This creates shorter names.
This attribute is inherited.

`block-prefix`:: If false, discard block prefix, in order to create shorter
names.  This attribute is inherited.

`pipeline`:: Finely define the pipelining.  In case of timing closure issues,
you can set this value to "all".  Possible values are "rd-in", "rd-out",
"wr-in", "wr-out".  Values starting with "wr-" act on signals for write
commands, while values starting with "rd-" act on signals for read commands.
Values finishing with "-in" acts on input signals, while values finishing
with "-out" acts on output signals.  So for example "wr-in" adds a
registers on input signals for write commands.  It is possible to use a
set of values separated by commas.  The default is "wr-in,rd-out".
There are also aliases: "wr" is for "wr-in,wr-out", "rd" for "rd-in,rd-out",
"in" for "wr-in,rd-in" and "out" for "wr-out,rd-out".
Finally it is possible to use "none" not to use any pipelining.
The pipelining is a single barrier of registers inserted on an internal bus,
which is created from the external bus.
Please note, that without correct pipelining of the write request and read
response ("wr-in,rd-out"), the `apb-32` interface might complete its write and
read request without the access phase and hence, in a single clock cycle only
(contrary to the standard's specifications). Also in case of a write request,
the updated data might be applied earlier than at the end of the access phase
(contrary to the standard's specifications).

`name-suffix`:: The name of the hdl entity or module is by default the name of
the memory map.  This attribute adds a suffix to those names.

`bus-granularity`:: Specify the granularity of the addresses. If set to
`word`, the address bus LSB bits are omitted.  So if a word is 4
bytes, the address bus start at bit 2.  If set to `byte`, the address
bus start at 0 (but those extra bits are ignored).  The default is
`word` and this option is currently only supported by the axi4-lite
bus and ignored by the other buses.  The purpose of this option is for
compatibility with Xilinx Vivado graphical tools.

`bus-error`:: Use the dedicated bus features to signal an error in case of
an addressing error, i.e. when accessing an address without corresponding
mapping, or an invalid request, i.e. when making a write request to a
write-only register. The value is a boolean. By default this option is
disabled. Only the following bus interfaces are supported:

** `apb-32`: In case of an error, the APB slave error signal (`PSLVERR`) is
asserted as soon as the request is acknowledged (`PREADY` is asserted).

** `axi4-lite-32`: In case of an error, the AXI4 Lite response signal (`BRESP`
or `RRESP`) is non-zero returning `SLVERR` (`0b10`).

** `wb-*`: In case of an error, the request is not acknowledged (`ACK` stays
deasserted) but instead an error is returned (`ERR` is asserted).

`wmask`:: Enable the masking of the write data in a write request through the
dedicated bus features. The value is a boolean. By default this option is
disabled. Only the following bus interfaces are supported:

** `apb-32`: Using the `PSTRB` signal a Byte-wise mask is applied.

** `avalon-lite-32`: Using the `BE` signal a Byte-wise mask is applied.

** `axi4-lite-32`: Using the `WSTRB` signal a Byte-wise mask is applied.

** `wb-*`: Using the `SEL` signal a Byte-wise mask is applied.

`lock-port`:: Adds a single-bit input port to the interface used as a lock
indication. If asserted, all registers and fields with a `lock` attribute
cannot be written to and their value remains constant or changes to a
predefined value.

`bus-attribute`:: Specify here 'Xilinx' in order to add dedicated
X_INTERFACE_INFO port attributes to the bus signals, which can help
for bus recognition by Xilinx/AMD IP Integrator tool.

=== Registers

A register uses one (usual case) or two (for 64-bit registers) words address.
It can be directly read or written by the CPU and each used bit or group of
bits generates a port.

The access mode is defined from the point of view of the software.  It slightly
change the generated hardware:

* rw (read/write): This generates flip-flops whose value is directly
available to the hardware.  The software can write to modify the value or
read the get the current value.  The hardware cannot change the value.

* wo (write-only): Like `rw`, but the software cannot read the current value.

* ro (read-only): This creates no hardware but just a port.  The software can
read the current value of the port, and cannot modify it.

The size (in bits) of the register can be specified by the `width` attribute.
The size can be larger than a word (but then you have to consider word
endianness issues).

It is possible to have fields in a register.  A field is a group of
consecutive bits and has a name.

If there is no field, this is a plain register.

The following attributes under `x-hdl` are supported:

`write-strobe`:: True to generate an additional signal that is
asserted when the register is written by the host.  The name of the
signal is '_wr_o' appended to the name of the register.  The strobe
signal is asserted for one cycle when a write request for this
register is detected.

`read-strobe`:: True to generate an additional signal that is asserted
when the register is read by the host.  The name of the signal is
'_rd_o' appended to the name of the register.  The strobe signal is
asserted for one cycle.

`write-ack`:: True to generate an additional signal for the write ack.  The
user must assert this signal for one cycle to acknowledge the write.  It
doesn't make sense to have this signal without the write strobe signal.  The
name of the signal is '_wack_i' appended to the name of the register.

`read-ack`:: True to generate an additional signal for the read ack.  The user
must assert this signal for one cycle to acknowledge the read.  It doesn't
make sense to have this signal without the read strobe signal.  The name of
the signal is '_rack_i' appended to the name of the register.

`port`:: Defines how ports are created and only when there are fields.
When set to `reg`, only one port per direction is created using the
size of the register.  User has to extract the fields from this port.  When
set to `field` (the default), ports are created for each field.

`type`:: Provide a default value for the `type` attribute of fields.  A field
can overwrite the value.  See fields for the values.


==== Plain Registers

A plain register has a type, which could be `unsigned` (the default), `signed` or
`float`.  The type has no impact on the hardware, but changes the
software view.

It is possible to define the initial (just after a reset) value of a
register using the `preset` attribute.  It is also possible, but not enabled
by default, to set the value of the register when the device starts (if
supported by your platform) to the `preset` attribute (see `--hdl-preload`).

For 32 bit registers, you can
also use the map version (set in the root) as the initial value by
giving the value `version` to the `preset` attribute.  Bits 0 to 7 are
set to the patch level, bits 8 to 15 to the minor version and bits 16
to 23 to the major.  You cannot have both `preset` and `constant` attributes.

Using the `constant` attribute, you can also give the value of attributes
from the root `x-map-info` mapping.  When the `constant` attribute of
a register is set to `memmap-version`, the value of the register is set
to the value of the memmap-version.  Likewise for `ident`.

Setting the `lock` attribute to true, a writable register or field can be
temporarily locked. While being locked, the register or field maintains its
current value and ignores any write requests. Furthermore, while being locked,
the output can also be altered to a predetermined value set via `lock-value`
attribute. The locking behavior is controlled via an external signal (defined
through the `lock-port` attribute on the memory map).

The `type` attribute within `x-hdl` is available and behaves as
defined below in the section for fields.

Example of a plain register:

[source]
----
    - reg:
        name: reg1
        description: a reg without fields
        width: 32
        access: rw
        type: unsigned
        preset: 0x123
----

==== Fields

There can be several fields in a register, and all of them have the same
access right.  Bits used by a field are specified by the `range` attribute.
The range is a single number if the field is 1 bit, or in the form of `hi-lo`
where `lo` is the lowest bit and `hi` is the highest bit.  Bits are numbered
using the little endian convention.

It is possible to define the initial (reset) value of a field using the
`preset` attribute. It is possible to define the value of a field used during
an active test using the `test-value` attribute.

It is possible to use a different type than the register type (which
acts as the default type). The `float` type is not available for
fields. It is however possible to use an enumeration type by using the
<<Extensions, x-enums extension>>, where its name must be defined in
the root `x-enums` extension.  The width of the field must be the same
as the width of the enumeration.

The `type` attribute within `x-hdl` is available.  It can be set to:

`reg`:: A register is created which can be read or written from the
bus.  The value of the register is available on the ports.  This is
the default unless register access type is `ro`.

`no-port`:: A register is created that can be read or written from the bus but
has no input or output ports. It can be used like a small memory.

`wire`:: No logic is created.  In case of read from the bus, the current
value on the input ports is returned.  The output ports are directly connected
to the data bus.  It doesn't make sense not to also have a strobe port for
write.  A `wire` cannot have a `preset` attribute.  This is the default when
the access type is `ro`.

`const`:: No output available, the value is a constant, set by the `preset`
attribute.

`autoclear`:: Only for outputs.  In case of a write from the bus, the value
is set on the output ports for only one clock cycle and then cleared.

`or-clr`, `or-clr-out`:: A register is created, and the current value is or-ed
with the input port. The register is cleared on a write (when bits are 1).
This allows to capture events. The `or-clr-out` also outputs the resulting
signal. This can be particularly useful to implement  level-based interrupts.
Software developers should be careful when using these registers: they should
only clear bits that were read as 1; otherwise they could miss events.

Example of a register with two fields:

[source]
----
    - reg:
        name: reg0
        description: a normal reg with some fields
        width: 32
        access: rw
        children:
          - field:
              name: field0
              description: 1-bit field
              range: 1
          - field:
              name: field1
              description: a field with a preset value
              range: 10-8
              preset: 2
----

=== Blocks

A block is simply a group of elements (registers, rams, submaps or blocks).
This is used only to create a hierarchy, but also offers the possibility
to specify an address or an alignment.

It is possible to reserve space at the end of a block with the `size`
attribute.  It specifies the size (in bytes) of the block. The suffixes k, M
and G are allowed.

The `block-prefix` and `reg-prefix` attributes are available within `x-hdl`,
to control name generation.

Example of a block:

[source]
----
    - block:
        name: block1
        description: A block of registers
        children:
        - reg:
           name: b1reg0
           access: wo
           width: 32
----

=== RAMs

A RAM is represented by an `memory` element with one register as a
child.  The total size of the ram is specified by the `memsize`
attribute (usually it should be a power of 2) and allows k, M or G
suffixes.  Instead of the total size, the number of elements can be
specified by the `memdepth` attribute.  Note that the width of the ram
(the number of address lines) is computed from the size of the ram and
the size of the register.

Unless the attribute `interface` is present, the memory is
automatically instantiated using `cheby_dpssram` (Dual Port Simple
SRAM) from https://ohwr.org/project/general-cores[OHWR
general-cores]. Otherwise the attribute specifies the type of
<<Header,bus>>, like for an external submap.

If the `dual-clock` attribute of `x-hdl` is set to True, the external memory
port is clocked by an external input.

Example of a ram:

[source]
----
    - memory:
        name: ram_ro1
        memsize: 16
        children:
          - reg:
              name: value
              access: rw
              width: 32
----

=== Repetition

It is possible to replicate elements using `repeat`.  The number of
repetitions is set by the `count` attribute.

Be careful that such a repetition can generate a lot of hardware.

Example of a replication:

[source]
----
    - repeat:
        name: arr1
        count: 2
        children:
          - reg:
              name: areg1
              access: rw
              width: 32
----

=== Submap

If the `filename` attribute is not present, then this is a generic
submap and a bus port is generated in the HDL. The size of the submap
is required. The attribute `interface` specifies which interface is
used for the connection, see the <<Header,bus>> attribute.

Example of a generic submap:

[source]
----
    - submap:
        name: sub3
        size: 0x1000
        description: A bus
        interface: wb-32-be
----

If the `filename` attribute is present, the `size` attribute is not allowed as
the size of the submap is defined by the memory map given by the file.  If the
`include` attribute is present and set to `True`, then the memory map
described by the file is included directly, otherwise a bus interface is
generated in the HDL.

Example of a normal submap:

[source]
----
    - submap:
        name: sub1
        description: A normal submap
        filename: demo_all_sub.cheby
----

Example of an included submap:

[source]
----
    - submap:
        name: sub2
        description: An included submap
        filename: demo_all_sub.cheby
        include: True
----

=== Address-space

This concept was introduced for more complex memory maps where there might be
an address overlap software-side due to the use of for instance PCI BARs.
It is mainly used in conjunction with the `x-driver-edge` extension.

Its use is restricted to the top level only. For HDL generation the address-
space needs to be specified as follows:

[source]
---
cheby --gen-hdl --address-space bar0 -i INPUT.cheby
---

An address-space requires a `name` and `children` nodes.

==  Generated HDL

For all buses, only word accesses are supported.  Sub-word (byte or half-word)
accesses are considered as word accesses (which can lead to error when
writing).

Addresses are byte addresses unless `bus-granularity` is set to `word`.

For registers longer than a word on a big-endian bus, the most significant
word is at the lowest address. There is one bit per word for strobe bits, and
they follow word order (bit 0 strobes the lowest word).

===  Semantics

The value of any unused field (within a defined register) is always read as 0.
This is to allow future compatibility.  However undefined addresses may
return any value.  In case of read or write to an undefined address, the
transaction is acknowledge (or passed to a submodule or a submap).  Code
generated by Cheby never blocks a request.

===  AXI4-Lite

There are several restrictions from the AMBA AXI standard:

* There can be no combinatorial paths between input and output
signals (A3.2.1).  So there must be at least one register.

* A source is not permitted to wait until READY is asserted before
asserting VALID.  Likewise, a destination is permitted to wait for
VALID to be assert before asserting the corresponding READY (A3.2.1).

There are registers for each channel.  The AW and W channels wait until both
have a request, handle the request and then become ready.  The B channel
becomes valid the next cycle, until ready is asserted.

Note that AXI4 addresses are byte addresses as specified in A3.4.1, but LSB
bits may be omitted with the `bus-granularity` attribute.

By default the AXI4-Lite interface uses one port per signal. It is
possible to group all signals in one input and one output port by
setting the `x-hdl.busgroup` attribute to `True`. The VHDL package can
be found as an appendix here. The library where the VHDL package is compiled
can be specified through the command line tool for x-hdl generation by adding
the argument:
[source]
----
 --axil-lib-name
----
=== Wishbone

The normal wishbone protocol is used (and not the pipelined one).

The `err` (error) and `rty` (retry) are always ignored (as inputs) and
never asserted as output.

By default the wishbone interface uses one port per wishbone signal.
It is possible to group all signals in one input and one output port
by setting the `x-hdl.busgroup` attribute to `True`. The VHDL package,
originating from https://ohwr.org/project/general-cores[OHWR
general-cores], can also be found as an appendix here. The library 
where the VHDL package is compiled can be specified through the command 
line tool for x-hdl generation by adding the argument:
[source]
----
 --wb-lib-name
----

== Gena Compatibility

For Cheburashka/Gena users, there is a simple transition path.  You can
convert a regular Cheburashka XML file to the cheby format using `gena2cheby`:

[source]
----
  $ gena2cheby FILE.xml
----

This tool writes on the standard output a cheby file.  Note that this file
contains several extensions (under `x-gena` arrays) so that all the feature
of the XML file are kept.

It is possible to generate a VHDL file (that is very similar to the VHDL
file generated by Gena) using cheby:

[source]
----
  $ cheby --gen-gena-regctrl=OUTPUT.vhdl -i INPUT.cheby
  $ cheby --gen-gena-memmap=OUTPUT.vhdl -i INPUT.cheby
----

Use the `--gena-commonvisual` option of `--gen-gena-regctrl` to use components
from the CommonVisual library instead of generating directly the code for them.

The `cheby` tool can also generate the C and header files for DSP access:

[source]
----
  $ cheby --gen-gena-dsp -i INPUT.cheby
----

This will creates `DSP/include/MemMapDSP_X.h`, `DSP/include/vmeacc_X.h` and
`DSP/vmeacc_X.c` (where `X` is the name of the design.

You can also generate each file individually:

[source]
----
  $ cheby --gen-gena-dsp-map=OUTPUT.h -i INPUT.cheby
  $ cheby --gen-gena-dsp-h=OUTPUT.h -i INPUT.cheby
  $ cheby --gen-gena-dsp-c=OUTPUT.c -i INPUT.cheby
----

== wbgen Compatibility

There is also a transition path for wbgen users.  If you have a fully
declarative and well formed wbgen file, you can convert it to the cheby
file:

[source]
----
  $ wbgen2cheby FILE.wb
----

This generate a cheby file on the standard output.  Note that this file
contains extensions using `x-wbgen` arrays.

It is possible to generate a VHDL file that is very similar to the VHDL
file generated by wbgen using cheby:

[source]
----
  $ cheby --gen-wbgen-hdl=OUTPUT.vhdl -i INPUT.cheby
----

== Cheby Command-Line Tool

The `cheby` tool can generate various files from an input file.  The input
file must be specified with the `-i` flag:

[source]
----
  $ cheby ACTION1 ACTION2... -i INPUT.cheby
----

An action flag is a flag optionally followed by a file name.  If the file name
is not present, the result is sent to the standard output.

[source]
----
  $ cheby --gen-hdl=output.vhdl -i input.cheby
  $ cheby --gen-hdl -i input.cheby
----

=== Generating HDL

Either VHDL or verilog can be generated by `cheby`.  You can specify the
language (either `vhdl` or `verilog`/`sv`) with the `--hdl` flag, the default
being `vhdl`.

[source]
----
  $ cheby --hdl=vhdl --gen-hdl=OUTPUT.vhdl -i INPUT.cheby
----

By default, there is a comment header (at the start of the hdl file) with
the options used to generate the file, the date of generation and the
author.  You can disable this header generation using `--header=none`
option.  You can remove the date and author using `--header=commit`.

By default, the `preset` attribute of registers is only used within the generated
reset routine.  Modern FPGAs allow you to preload a value in registers as well,
which alleviates the need to reset the board on start-up.  To preload the preset value
into registers, you can use the `--hdl-preload` option.

=== Generating EDGE file

You can generate an EDGE block definition (in CSV) with the
`--gen-edge` flag.  Note that you need to provide the other part of
the files.

[source]
----
  $ cheby --gen-edge -i INPUT.cheby
----

=== Generating C header

The definition of a C structure representing the layout of the design is
generated using the `--gen-c` flag.

[source]
----
  $ cheby --gen-c -i INPUT.cheby
----

Through the submap feature of Cheby, a design can reference another
design stored in a different file. In the header file generated, the
structure for the referenced design is not redefined, but imported
through an `include` directive, using the `DESIGN.h` name (without any
directory).  So it is expected that either all the headers are stored
in the same directory or that the include paths are specified to the
C compiler (using `-I` for example).

The generated header files use the standard integer types defined in
`<stdint.h>`, but without including `<stdint.h>`.  This is done on purpose so
that the file can still be used on systems that don't have `stdint.h`.  So
you need to include `stdint.h` before including the generated header files,
or to include an equivalent header file.

With the option `--c-style=arm`, the header generated follows more closely
the CMSIS style.

Inner blocks (like `block` or `repeat`) are represented by C `struct`.
If the option `prefix-struct` in extension `x-c-header` at the root is
set, the structure tag will be prefixed by the name of the root.
It avoids compiler errors if the name of the block is used in different
designs.  It is strongly recommended to set this attribute.

The `--gen-c-bit-struct` option adds C `struct`s also for bit fields within
registers. Note that bit-field structures depend on implementation-defined (i.e.
compiler and ABI-dependent) behavior. The order of bit fields may not be
respected. For more information, refer to C Spec C99 6.7.2.1-11.

It is also possible to generate a C program that check the layout is the same
as the layout seen by Cheby.  This can be used as a consistency check.

[source]
----
  $ cheby --gen-c-check-layout -i INPUT.cheby
----

=== Generating documentation

Documentation can be generated either in HTML, Latex, or in markdown (tested with
asciidoctor).  The format is specified by the `--doc=FORMAT` flag and the
format is either `html`, `latex`, or `md`.

[source]
----
  $ cheby --doc=md --gen-doc=OUTPUT.md -i INPUT.cheby
----

The generated Latex file is meant to be included from a main file. An example
for such a file can be created using `--doc-copy-template`:

[source]
----
  $ cheby --doc latex --doc-copy-template main.tex -i INPUT.cheby
----

=== Generating constants file

In order to write testbench, you can generate an include files that
defines the address of the registers, the offset and a mask for each fields.

[source]
----
  $ cheby --consts-style=STYLE --gen-consts -i INPUT.cheby
----

The `STYLE` can be either `h`, `matlab`, `python`, `sv`, `tcl`, `verilog`,
`vhdl`, `vhdl-ohwr`, or `vhdl-orig`. For vhdl the addresses and the offsets are
integers, and the mask is not generated (as it would often overflow the integer
range).

Some styles also support the generation of structured constant files by adding a
`-struct` suffix to it. Thereby, the constants are grouped in a hierarchical
structure instead of individual constants. E.g., `matlab-struct`.

Constants available in generated files are:

* For modules:
  * `<HNAME>_SIZE`: Size
  * `ADDR_<HNAME>`: Address
  * `ADDR_MASK_<HNAME>`: Relative address mask (bits of the address relevant to that specific module)
  * `ADDR_FMASK_<HNAME>`: Final address mask
* For registers:
  * `ADDR_<HNAME>`: Address
  * `<HNAME>_PRESET`: Preset value where applicable
* For bitfields:
  * `ADDR_<HNAME>`: Address (same as parent register address)
  * `<HNAME>_WIDTH`: Width (in bits)
  * `<HNAME>_OFFSET`: Offset (in bits)
  * `<HNAME>`: Bitmask
  * `<HNAME>_PRESET`: Preset value where applicable

=== Generating SILECS file

It is possible to generate SILECS
(https://confluence.cern.ch/display/SIL/Design+document) XML file from a
Cheby description.  Not all features of Cheby are supported: only registers.

[source]
----
  $ cheby --gen-silecs -i INPUT.cheby
----

=== Custom pass

If you need a very specific feature, you can implement your own pass, and invoke it
using `--gen-custom`:

[source]
----
  $ cheby --gen-custom[=OUTPUT] -i INPUT.cheby
----

The Cheby tool will read the `gen_custom.py` file in the current directory and call
the `generate_custom` function.

=== Generating text files

It is possible to general a compact text file describing the layout of
a cheby file with the `--print-memmap` flag.  This could be useful to have
a quick look on alignment effects.

[source]
----
  $ cheby --print-memmap -i INPUT.cheby
----

To display the fields, use `--print-simple`:

[source]
----
  $ cheby --print-simple -i INPUT.cheby
----

When a part of the design is replicated (using the `repeat` attribute) you
can view the effect of it with the `--print-simple-expanded` flag.

[source]
----
  $ cheby --print-simple-expanded -i INPUT.cheby
----

Finally to regenerated the initial file (properly indented but without the
comments), you can use `--print-pretty` or `--print-pretty-expanded`.

== Extensions

include::cheby-extensions.adoc[]

[appendix]
== axi4lite_pkg
[source]
----
include::../testfiles/tb/axi4lite_pkg.vhd[]
----

[appendix]
== wishbone_pkg
[source]
----
include::../testfiles/tb/wishbone_pkg.vhd[]
----
